#! /bin/bash

exec 0<$1.gopts 1>$1.generated
chmod +x $1.generated

gen_option()
{
    SHORTOPT=
    LONGOPT=
    FIRSTARG=true
    DEFAULT=
    for i in $1
    do
    case $i in
	--* )
	    $FIRSTARG && echo >&2 "Error: No OPTNAME in $1"
	    FIRSTARG=false
	    REQ_ARG=true
	    LONGOPT="$i"
	    LONGPARSE="$LONGPARSE
	${i%%=*} )
	    [[ \$# < 2 ]] && opt_err_req_arg $i
	    shift
	    OPTARG_$OPTNAME=true
	    OPTVAL_$OPTNAME=\"\$1\"
	    ;;
	${i%%=*}=* )
	    OPTARG_$OPTNAME=true
	    OPTVAL_$OPTNAME=\"\${1#${i%%=*}=}\"
	    ;;"
	    ;;
	-* )
	    $FIRSTARG && echo >&2 "Error: No OPTNAME in $1"
	    FIRSTARG=false
	    REQ_SARG=true
	    SHORTOPT="$i"
	    SHORTPARSE="$SHORTPARSE
		${i:1:1} )
		    OPTARG_$OPTNAME=true
		    OPTVAL_$OPTNAME=\"\${OPTTMP:1}\"
		    if [[ -z \"\$OPTVAL_$OPTNAME\" ]]
		    then
			[[ \$# < 2 ]] && opt_err_req_sarg ${i:1:1}
			shift
			OPTVAL_$OPTNAME=\"\$1\"
		    else
			break
		    fi
		    ;;"
	    ;;
	* )
	    if $FIRSTARG
	    then
		FIRSTARG=false
		OPTNAME="$i"
	    else
		DEFAULT="$i"
	    fi
	    ;;
	esac
    done
    DEFVARS="$DEFVARS
OPTARG_$OPTNAME=false
OPTVAL_$OPTNAME=$DEFAULT"
    genhelp "$SHORTOPT" "$LONGOPT" "$2"
}

gen_switch()
{
    SHORTOPT=
    LONGOPT=
    FIRSTARG=true
    for i in $1
    do
       case $i in
       --* )
	    $FIRSTARG && echo >&2 "Error: No OPTNAME in $1"
	    FIRSTARG=false
	    NO_ARG=true
	    LONGOPT="$i"
	    LONGPARSE="$LONGPARSE
	$i )
	    OPTARG_$OPTNAME=true
	    ;;
	$i=* )
	    opt_err_no_arg $i
	    ;;"
	    ;;
       -* )
	    $FIRSTARG && echo >&2 "Error: No OPTNAME in $1"
	    FIRSTARG=false
	    SHORTOPT="$i"
	    SHORTPARSE="$SHORTPARSE
		${i:1:1} )
		    OPTARG_$OPTNAME=true
		    ;;"
	    ;;
	* )
	    if $FIRSTARG
	    then
		FIRSTARG=false
		OPTNAME="$i"
	    else
		echo >&2 "No default allowed for @switch in $1"
	    fi
	    ;;
	esac
    done
    DEFVARS="$DEFVARS
OPTARG_$OPTNAME=false"
    genhelp "$SHORTOPT" "$LONGOPT" "$2"
}

genhelp()
{
OPTITA=
OPTITB=
    if [[ ! -z "$1" ]]
    then
	OPTITA=x
    fi
    if [[ ! -z "$2" ]]
    then
	OPTITB=y
    fi
    case "$OPTITA$OPTITB" in
	"" )
	    echo >&2 "Error: No options defined for for $2"
	    ;;
	x )
	    if [[ -z "${1:2}" ]]
	    then
		OPTSTRING="${1:0:2}"
	    else
		OPTSTRING="${1:0:2} ${1:3}"
	    fi
	    ;;
	y )
		OPTSTRING="    $2"
	    ;;
	xy )
		OPTSTRING="${1:0:2}, $2"
	    ;;
    esac
    if [[ ${#OPTSTRING} > $HELPSIZE ]]
    then HELPSIZE=${#OPTSTRING}
    fi
    dohelp "$OPTSTRING" "'${2//\'/\'}'"
    if [ "$SHORTOPTT$LONGOPTT" = xx ]
    then
	BOTHOPT="  $SHORTOPT, $LONGOPT"
    else
	BOTHOPT="  $SHORTOPT  $LONGOPT"
    fi
    HELP="$HELP
$BOTHOPT$2"
}

PROGRAM=
VERSION=
YEAR=
AUTHOR=
BUGSTO=
USAGE=
SHORT=
DEFAULTS_TXT=
DEFAULTS=
FREECOPY=
NLS=
NLSINIT=

DEFVARS=
LONGPARSE=
SHORTPARSE=
HELP=
HELPSIZE=0
REQ_ARG=false
NO_ARG=false
REQ_SARG=false

readto()
{
    REPLYTO=
    while :
    do
	read
	if [[ -z "$REPLY" ]]
	then break
	fi
    REPLYTO="$REPLYTO
$REPLY"
    done
    if [[ ! -z "$1" ]]
    then
	eval $1\=\"\$REPLYTO\"
    fi
}
readtoz()
{
    REPLYTO=
    while :
    do
	read
	if [[ -z "$REPLY" ]]
	then break
	fi
    if [[ -z "$REPLYTO" ]]
    then
    REPLYTO="$REPLY"
    else
    REPLYTO="$REPLYTO
$REPLY"
    fi
    done
    if [[ ! -z "$1" ]]
    then
	eval $1\=\"\$REPLYTO\"
    fi
}

while :
do
    read FUNC ARGS
    case "$FUNC" in
    @genopts )
	;;
    @program )
	PROGRAM="$ARGS"
	;;
    @version )
	VERSION="$ARGS"
	;;
    @year )
	YEAR="$ARGS"
	;;
    @author )
	AUTHOR="$ARGS"
	;;
    @bugsto )
	BUGSTO="
Report bugs to $ARGS."
	;;
    @usage )
	USAGE="$ARGS"
	;;
    @short )
	readto SHORT
	;;
    @defaults )
	readto DEFAULTS_TXT
	if [[ ! -z "$ARGS" ]]
	then
	    DEFAULTS_TXT="$DEFAULTS_TXT
Options can be stored in $ARGS environment variables."
	    DEFAULTS="\$$ARGS "
	fi
	[[ ! -z DEFAULTS_TXT ]] && DEFAULTS_TXT="$DEFAULTS_TXT
"
	;;
    @free_copy )
	FREECOPY='
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'
	;;
    @textdomain )
	NLS='$'
	NLSINIT='

TEXTDOMAIN=$ARGS'
	;;
    @end )
	gen_switch "HELP -h --help" 'display this help and exit'
	gen_switch "VERSION --version"  'output version information and exit'
	break
	;;
    "" )
	;;
    @switch )
	readtoz
	gen_switch "$ARGS" "$REPLYTO"
	;;
    @option )
	readtoz
	gen_option "$ARGS" "$REPLYTO"
	;;
    * )
	echo >&2 "Warning: Unknown token $FUNC."
    esac
done

echo '#! /bin/bash
# This file is generated by genopts from '"$1"'.gopts'"$NLSINIT"'.

opt_err()
{
    echo '"$NLS"'"$0: $1
Try \`$0 --help'\'' for more information." >&2
    exit 1
}

opt_err_bad_arg()
{
    opt_err '"$NLS"'"unrecognized option \`$1'\''"
}

opt_err_bad_sarg()
{
    opt_err '"$NLS"'"invalid option -- $1"
}'

if $REQ_ARG
then echo '
opt_err_req_arg()
{
    opt_err '"$NLS"'"option \`$1'\'' requires an argument"
}'
fi

if $NO_ARG
then echo '
opt_err_no_arg()
{
    opt_err '"$NLS"'"option \`$1'\'' doesn'\''t allow an argument"
}'
fi

if $REQ_SARG
then echo '
opt_err_req_sarg()
{
    opt_err '"$NLS"'"ls: option requires an argument -- $1"
}'
fi

echo '
opt_arg_version()
{
    echo '"$NLS\"$PROGRAM $VERSION
Written by $AUTHOR.

Copyright (C) $YEAR $AUTHOR$FREECOPY\"
    exit 0
}

opt_arg_usage()
{
    echo $NLS\"Usage: \$0 $USAGE$SHORT
$HELP
$DEFAULTS_TXT$BUGSTO\"
    exit 0
}
$DEFVARS"

echo '
optarg_parse()
{
    until [ $# -eq 0 ]
    do
	case "$1" in'"$LONGPARSE"'
	-- )
	    shift
	    ARGLIST=("${ARGLIST[@]}" "$@")
	    break
	    ;;
	--* )
	    opt_err_bad_arg $1
	    ;;
	- )
	    ARGLIST=("${ARGLIST[@]}" "$1")
	    ;;
	-* )
	    OPTTMP="${1:1}"
	    until [[ -z "$OPTTMP" ]]
	    do
	    echo "/${OPTTMP:1}/${OPTTMP:0:1}/${OPTTMP:1}/"
		case "${OPTTMP:0:1}" in'"$SHORTPARSE"'
		* )
		    opt_err_bad_sarg ${OPTTMP:0:1}
		    ;;
		esac
	    OPTTMP="${OPTTMP:1}"
	    done
	    ;;
	* )
	    ARGLIST=("${ARGLIST[@]}" "$1")
	    ;;
	esac
    shift
    done
}

optarg_parse '"$DEFAULTS"'"$@"

$OPTARG_HELP && opt_arg_usage
$OPTARG_VERSION && opt_arg_version

unset opt_err opt_err_bad_arg opt_err_bad_sarg\'

if $REQ_ARG
then echo -n ' opt_err_req_arg'
fi

if $NO_ARG
then echo -n ' opt_err_no_arg'
fi

if $REQ_SARG
then echo -n ' opt_err_req_sarg'
fi

echo ' opt_arg_version\
 opt_arg_usage optarg_parse OPTTMP

# end of parser
'

while read
do
    echo "$REPLY"
done
